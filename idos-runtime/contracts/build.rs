use std::io::Write;
use std::path::{Path, PathBuf};

use ethers::contract::Abigen;

fn main() {
    
}

fn main1() {
    let idos_contracts_dir = package_dir().to_string_lossy().into_owned();
    let lib_path = format!("{idos_contracts_dir}/src/lib.rs");
    let mut lib = std::fs::File::create(&lib_path).unwrap();

    writeln!(lib, "// DO NOT EDIT! This file was generated by build.rs").unwrap();
    // writeln!(lib, "#[macro_use]\nmod convert;").unwrap();

    let contracts = vec!["IDataverseRelayer", "IDataverseVerifier"];
    for contract_name in contracts {
        let module_name = camel_to_snake(contract_name);
        let input_path = format!("{idos_contracts_dir}/abi/{contract_name}.abi");
        let output_path = format!("{idos_contracts_dir}/src/{}.rs", module_name);

        println!("cargo:warning={contract_name}:{input_path} {output_path}");
        Abigen::new(contract_name, &input_path)
            .expect("failed to create Abigen")
            .generate()
            .expect("failed to generate Rust bindings")
            .write_to_file(output_path)
            .expect("failed to write Rust code");

        writeln!(lib, "#[allow(clippy::all)]\npub mod {module_name};").unwrap();
        println!("cargo:rerun-if-changed={input_path}");
    }
}

fn camel_to_snake(name: &str) -> String {
    let mut out = String::new();
    for (i, c) in name.chars().enumerate() {
        match (i, c) {
            (0, c) if c.is_uppercase() => {
                out.push(c.to_ascii_lowercase());
            }
            (_, c) if c.is_uppercase() => {
                out.push('_');
                out.push(c.to_ascii_lowercase());
            }
            (_, c) => {
                out.push(c);
            }
        }
    }
    out
}

fn package_dir() -> PathBuf {
    let output = std::process::Command::new(env!("CARGO"))
        .arg("locate-project")
        .arg("--message-format=plain")
        .output()
        .unwrap()
        .stdout;

    let cargo_path = Path::new(std::str::from_utf8(&output).unwrap().trim());
    cargo_path.parent().unwrap().to_path_buf()
}
